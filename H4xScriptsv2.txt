-- üî¥ Load WindUI
local success, WindUI = pcall(function()
    return loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
end)
if not success or not WindUI then
    warn("‚ùå Failed to load WindUI")
    return
end

-- üåà Add all themes
local themeNames = {
    "Ocean Blue","Forest Green","Minimal Light","Retro Purple","Sunset",
    "Neon Pulse","Steel Phantom","Vaporwave","Deep Sea","Sepia Warmth",
    "Monokai Dark","Solarized Light","Cherry Blossom","Charcoal Gold",
    "Icy Mint","Volcano","Amethyst","Pastel Dream","Coffee Shop","Cyberpunk Red"
}

-- Example: Adding all themes
local themeColors = {
    ["Ocean Blue"] = {Accent="#0B5394", Dialog="#0A3D6B", Outline="#6DACEA", Text="#EBF5FF", Placeholder="#85AECF", Background="#051A2E", Button="#1C67A8", Icon="#A9D5FD"},
    ["Forest Green"] = {Accent="#1A5E2E", Dialog="#114220", Outline="#8AC79B", Text="#E9FCE9", Placeholder="#79A378", Background="#0A2B14", Button="#2B7A42", Icon="#B3E3C1"},
    ["Minimal Light"] = {Accent="#F3F4F6", Dialog="#FFFFFF", Outline="#4B5563", Text="#1F2937", Placeholder="#9CA3AF", Background="#F9FAFB", Button="#E5E7EB", Icon="#4B5563"},
    ["Retro Purple"] = {Accent="#7E22CE", Dialog="#4A148C", Outline="#F0ABFC", Text="#FDF4FF", Placeholder="#BC8FDD", Background="#2D0557", Button="#9333EA", Icon="#F0ABFC"},
    ["Sunset"] = {Accent="#FF8847", Dialog="#CC5500", Outline="#FFD9C0", Text="#FFF7F0", Placeholder="#FFC099", Background="#331A00", Button="#FF7043", Icon="#FFD9C0"},
    ["Neon Pulse"] = {Accent="#00FF00", Dialog="#111111", Outline="#00FFFF", Text="#FFFFFF", Placeholder="#008800", Background="#000000", Button="#39FF14", Icon="#00FFFF"},
    ["Steel Phantom"] = {Accent="#404040", Dialog="#262626", Outline="#A3A3A3", Text="#D4D4D4", Placeholder="#737373", Background="#171717", Button="#525252", Icon="#A3A3A3"},
    ["Vaporwave"] = {Accent="#FF00FF", Dialog="#1B001B", Outline="#00FFFF", Text="#FFFFFF", Placeholder="#FF69FF", Background="#0A0014", Button="#E75480", Icon="#00FFFF"},
    ["Deep Sea"] = {Accent="#008B8B", Dialog="#005A5A", Outline="#80CBC4", Text="#E0FFFF", Placeholder="#4DB6AC", Background="#003636", Button="#00A3A3", Icon="#80CBC4"},
    ["Sepia Warmth"] = {Accent="#7B3F00", Dialog="#5C3200", Outline="#D2B48C", Text="#F5E8D6", Placeholder="#A98F70", Background="#3D291F", Button="#9D5B18", Icon="#D2B48C"},
    ["Monokai Dark"] = {Accent="#F92672", Dialog="#272822", Outline="#66D9EF", Text="#F8F8F2", Placeholder="#75715E", Background="#1C1E1A", Button="#A6E22E", Icon="#66D9EF"},
    ["Solarized Light"] = {Accent="#268BD2", Dialog="#FDF6E3", Outline="#93A1A1", Text="#586E75", Placeholder="#839496", Background="#EEE8D5", Button="#B58900", Icon="#268BD2"},
    ["Cherry Blossom"] = {Accent="#F9BCCB", Dialog="#FFFAFD", Outline="#D96985", Text="#4A1429", Placeholder="#C397A3", Background="#FFF7F9", Button="#E68A9F", Icon="#D96985"},
    ["Charcoal Gold"] = {Accent="#FFD700", Dialog="#2C2C2C", Outline="#C0C0C0", Text="#F5F5F5", Placeholder="#6E6E6E", Background="#1D1D1D", Button="#B8860B", Icon="#FFD700"},
    ["Icy Mint"] = {Accent="#40E0D0", Dialog="#F0FFFF", Outline="#81D4FA", Text="#004D40", Placeholder="#B2DFDB", Background="#E0FFFF", Button="#80CBC4", Icon="#40E0D0"},
    ["Volcano"] = {Accent="#B22222", Dialog="#1C1C1C", Outline="#FF6347", Text="#EBEBEB", Placeholder="#704747", Background="#0A0A0A", Button="#FF4500", Icon="#FF6347"},
    ["Amethyst"] = {Accent="#9966CC", Dialog="#36284C", Outline="#CCFF66", Text="#EDE9F2", Placeholder="#8A72A4", Background="#221A33", Button="#7A52AA", Icon="#CCFF66"},
    ["Pastel Dream"] = {Accent="#FFB3BA", Dialog="#FAF3E0", Outline="#BAE1FF", Text="#333333", Placeholder="#C1B4A5", Background="#FFFFFF", Button="#BAE1FF", Icon="#FFB3BA"},
    ["Coffee Shop"] = {Accent="#795548", Dialog="#F5F5DC", Outline="#A1887F", Text="#3E2723", Placeholder="#BCB0A4", Background="#FFF8E1", Button="#D7CCC8", Icon="#795548"},
    ["Cyberpunk Red"] = {Accent="#FF3333", Dialog="#080008", Outline="#33FFFF", Text="#FDFDFD", Placeholder="#771111", Background="#000000", Button="#CC0000", Icon="#33FFFF"}
}

-- Add all themes to WindUI
for name, colors in pairs(themeColors) do
    WindUI:AddTheme({
        Name = name,
        Accent = Color3.fromHex(colors.Accent),
        Dialog = Color3.fromHex(colors.Dialog),
        Outline = Color3.fromHex(colors.Outline),
        Text = Color3.fromHex(colors.Text),
        Placeholder = Color3.fromHex(colors.Placeholder),
        Background = Color3.fromHex(colors.Background),
        Button = Color3.fromHex(colors.Button),
        Icon = Color3.fromHex(colors.Icon)
    })
end

WindUI:SetTheme("Volcano") -- default

WindUI:SetFont("rbxassetid://12187360881")

local function GradientText(text, color1, color2)
    local result = ""
    for i = 1, #text do
        local t = (i - 1) / (#text - 1)
        local r = color1.R + (color2.R - color1.R) * t
        local g = color1.G + (color2.G - color1.G) * t
        local b = color1.B + (color2.B - color1.B) * t
        local hex = string.format("#%02X%02X%02X", r * 255, g * 255, b * 255)
        result = result .. string.format('<font color="%s">%s</font>', hex, text:sub(i, i))
    end
    return result
end

local Window = WindUI:CreateWindow({
    Title = GradientText("H4xScripts", Color3.fromRGB(255, 0, 0), Color3.fromRGB(0, 0, 0)),
    Icon = "rbxassetid://80426684728669",
    IconThemed = "true",
    Author = "By @Pratik",
    Size = UDim2.fromOffset(580, 460),
    Resizable = true,
    Transparent = true,
})

Window:SetIconSize(50) -- default is 20

Window:EditOpenButton({
    Title =  GradientText("H4xScripts", Color3.fromRGB(255, 0, 0), Color3.fromRGB(0, 0, 0)),
    Icon = "rbxassetid://80426684728669",
    CornerRadius = UDim.new(0,16),
    StrokeThickness = 2,
    Color = ColorSequence.new( -- gradient
        Color3.fromHex("FF0F7B"), 
        Color3.fromHex("F89B29")
    ),
    OnlyMobile = false,
    Enabled = true,
    Draggable = true,
})

Window:DisableTopbarButtons({ "Close" })

local Info = Window:Tab({Title = "Information", Icon = "info" })

local InviteCode = "h4xscripts" -- change to your discord invite
local DiscordAPI = "https://discord.com/api/v10/invites/" .. InviteCode .. "?with_counts=true&with_expiration=true"

local Response
local ErrorMessage = nil

xpcall(function()
    Response = game:GetService("HttpService"):JSONDecode(WindUI.Creator.Request({
        Url = DiscordAPI,
        Method = "GET",
        Headers = {
            ["Accept"] = "application/json"
        }
    }).Body)
end, function(err)
    warn("err fetching discord info: " .. tostring(err))
    ErrorMessage = tostring(err)
    Response = nil
end)

if Response and Response.guild then
    local ParagraphConfig = {
        Title = Response.guild.name,
        Desc =
            ' <font color="#52525b">‚Ä¢</font> Member Count: ' .. tostring(Response.approximate_member_count) ..
            '\n <font color="#16a34a">‚Ä¢</font> Online Count: ' .. tostring(Response.approximate_presence_count)
        ,
        Image = "https://cdn.discordapp.com/icons/" .. Response.guild.id .. "/" .. Response.guild.icon .. ".png?size=256",
        ImageSize = 42,
        Buttons = {
            {
                Icon = "link",
                Title = "Copy Discord Invite",
                Callback = function()
                    pcall(function()
                        setclipboard("https://discord.gg/" .. InviteCode)
                    end)
                end
            },
            {
                Icon = "refresh-cw",
                Title = "Update Info",
                Callback = function()
                    xpcall(function()
                        local UpdatedResponse = game:GetService("HttpService"):JSONDecode(WindUI.Creator.Request({
                            Url = DiscordAPI,
                            Method = "GET",
                        }).Body)
                        
                        if UpdatedResponse and UpdatedResponse.guild then
                            DiscordInfo:SetDesc(
                                ' <font color="#52525b">‚Ä¢</font> Member Count: ' .. tostring(UpdatedResponse.approximate_member_count) ..
                                '\n <font color="#16a34a">‚Ä¢</font> Online Count: ' .. tostring(UpdatedResponse.approximate_presence_count)
                            )
                        end
                    end, function(err)
                        warn("err updating discord info: " .. tostring(err))
                    end)
                end
            }
        }
    }
    
    if Response.guild.banner then
        ParagraphConfig.Thumbnail = "https://cdn.discordapp.com/banners/" .. Response.guild.id .. "/" .. Response.guild.banner .. ".png?size=256"
        ParagraphConfig.ThumbnailSize = 80
    end
    
    local DiscordInfo = Info:Paragraph(ParagraphConfig)
else
    Info:Paragraph({
        Title = "Error when receiving information about the Discord server",
        Desc = ErrorMessage or "Unknown error occurred",
        Image = "triangle-alert",
        ImageSize = 26,
        Color = "Red",
    })
end

-- üìò Game Information Box (like ‚ÄúBubble Gum Simulator INFINITY‚Äù)
local GameInfo = Info:Paragraph({
    Title = GradientText("H4xScripts", Color3.fromRGB(255, 0, 0), Color3.fromRGB(0, 0, 0)),
    Desc = "Script made by @mallo",
    Color = "White",
})

-- üéÆ Supported Games Tab
local SupportedGamesTab = Window:Tab({
    Title = "Supported Games!", 
    Icon = "gamepad",
})

-- ü™ì Cut Trees Button
SupportedGamesTab:Button({
    Title = "Cut Trees", 
    Desc = "Teleport to Cut Trees!",
    Callback = function()
        -- Replace with Cut Trees game ID
        local cutTreesID = 16241018808 
        game:GetService("TeleportService"):Teleport(cutTreesID, game.Players.LocalPlayer)
    end
})

-- üé£ Fish It Button
SupportedGamesTab:Button({
    Title = "Fish It!", 
    Desc = "Teleport to Fish It!",
    Callback = function()
        -- Replace with Fish It game ID
        local fishItID = 17799431029 
        game:GetService("TeleportService"):Teleport(fishItID, game.Players.LocalPlayer)
    end
})

Window:Divider()

-- üêü Create Fishing Tab
local MainFarm = Window:Tab({
	Title = "Auto Farm", 
	Icon = "fish",
	Locked = false,
})

-- üìç Remote references
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local NetFolder = ReplicatedStorage:WaitForChild("Packages")
	:WaitForChild("_Index")
	:WaitForChild("sleitnick_net@0.2.0")
	:WaitForChild("net")

local EquipTool = NetFolder:WaitForChild("RE/EquipToolFromHotbar")
local ChargeRod = NetFolder:WaitForChild("RF/ChargeFishingRod")
local RequestMinigame = NetFolder:WaitForChild("RF/RequestFishingMinigameStarted")
local FishingDone = NetFolder:WaitForChild("RE/FishingCompleted")

-- üß† State
local autoFishEnabled = false

-- üé£ Auto Fish Toggle
MainFarm:Toggle({
	Title = "Auto Fish", 
	Icon = "anchor",
	Default = false,
	Callback = function(state)
		autoFishEnabled = state
		if state then
			print("[FishIt] üé£ Auto Fishing started")
			task.spawn(function()
				while autoFishEnabled do
					-- Equip Rod
					pcall(function()
						EquipTool:FireServer(1)
					end)
					task.wait(0.5)

					-- Charge Cast
					pcall(function()
						ChargeRod:InvokeServer(tick())
					end)

					-- Start Minigame
					pcall(function()
						RequestMinigame:InvokeServer(-1, 1)
					end)

					-- Normal catch flow: wait a bit then complete fishing
					task.wait(3 + math.random()) -- simulate waiting for bite/duration
					pcall(function()
						FishingDone:FireServer()
					end)
					print("[FishIt] üêü Fish caught!")

					task.wait(1.5)
				end
				print("[FishIt] ‚èπÔ∏è Auto Fishing stopped")
			end)
		end
	end,
})

-- üêü AUTO SELL TAB
-- ‚öôÔ∏è Game remotes
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local NetFolder = ReplicatedStorage:WaitForChild("Packages")
	:WaitForChild("_Index")
	:WaitForChild("sleitnick_net@0.2.0")
	:WaitForChild("net")

local SellAllRemote = NetFolder:FindFirstChild("RF/SellAllItems")
local SellItemRemote = NetFolder:FindFirstChild("RF/SellItem")

-- üí∞ Sell All Items Button
MainFarm:Button({
	Title = "Sell All Items", 
	Description = "Sells everything in your inventory.",
	Callback = function()
		if SellAllRemote then
			pcall(function()
				SellAllRemote:InvokeServer()
			end)
		else
			warn("SellAllItems remote not found!")
		end
	end
})

-- Add Auto Trick or Treat toggle to Mika's Hub Autofarm tab
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local net = ReplicatedStorage.Packages._Index["sleitnick_net@0.2.0"].net
local NPCFolder = workspace:WaitForChild("NPC")

local AutoTrickOrTreat = false

MainFarmTab:Toggle({
    Name = "Auto TrickOrTreat",
    Default = false,
    Callback = function(state)
        AutoTrickOrTreat = state
        if state then
            spawn(function()
                while AutoTrickOrTreat do
                    for _, npc in ipairs(NPCFolder:GetChildren()) do
                        if npc:IsA("Model") then
                            pcall(function()
                                net["RF/SpecialDialogueEvent"]:InvokeServer(npc.Name, "TrickOrTreat")
                            end)
                            wait(1) -- delay between NPCs
                        end
                    end
                    wait(5) -- wait before repeating all NPCs
                end
            end)
        end
    end
})

-- === TELEPORTS TAB ===
local TeleportsTab = Window:Tab({ Title = "Teleports", Icon = "map", Locked = false })

-- ========================
-- Island Teleports Section
-- ========================
local IslandSection = TeleportsTab:Section({
    Icon = "anchor",
    Title = "Island Teleport", 
})

local selectedIsland = nil
IslandSection:Dropdown({
    Title = "Select Island",
    Values = {"Kohana", "Fishermen", "Coral Reefs", "Tropical Grove", "Crater Island", "Lost Isle", "Ancient Jungle"},
    Default = "Kohana",
    Callback = function(value)
        selectedIsland = value
    end
})

IslandSection:Button({
    Title = "Teleport To Island", 
    Callback = function()
        if not selectedIsland then return warn("Select an island first!") end

        local IslandTeleports = {
            Kohana = Vector3.new(-643, 16.035, 613),
            Fishermen = Vector3.new(33, 9.785, 2816),
            ["Coral Reefs"] = Vector3.new(-2855, 47.5, 1978),
            ["Tropical Grove"] = Vector3.new(-2041, 53.486, 3738),
            ["Crater Island"] = Vector3.new(1217, 56.469, 5017),
            ["Lost Isle"] = Vector3.new(-3694, -135.574, -1038),
            ["Ancient Jungle"] = Vector3.new(1277, 7.858, -195)
        }

        local pos = IslandTeleports[selectedIsland]
        local player = game.Players.LocalPlayer
        local char = player.Character or player.CharacterAdded:Wait()
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if hrp then
            hrp.CFrame = CFrame.new(pos)
        else
            warn("HumanoidRootPart not found.")
        end
    end
})

-- ========================
-- Misc Teleports Section
-- ========================
local MiscSection = TeleportsTab:Section({
    Icon = "compass",
    Title = "Misc Teleport", 
})

local selectedMisc = nil
MiscSection:Dropdown({
    Title = "Select Location",
    Values = {"Lohana Volcano", "Weather Control"},
    Default = "Lohana Volcano",
    Callback = function(value)
        selectedMisc = value
    end
})

MiscSection:Button({
    Title = "Teleport To Misc", 
    Callback = function()
        if not selectedMisc then return warn("Select a location first!") end

        local MiscTeleports = {
            ["Kohana Volcano"] = Vector3.new(-585, 48.959, 214),
            ["Weather Control"] = Vector3.new(-1497, 6.5, 1892)
        }

        local pos = MiscTeleports[selectedMisc]
        local player = game.Players.LocalPlayer
        local char = player.Character or player.CharacterAdded:Wait()
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if hrp then
            hrp.CFrame = CFrame.new(pos)
        else
            warn("HumanoidRootPart not found.")
        end
    end
})

-- ========================
-- NPC Teleports Section
-- ========================
local NPCSection = TeleportsTab:Section({
    Icon = "user",
    Title = "NPC Teleport", 
})

local selectedNPC = nil
NPCSection:Dropdown({
    Title = "Select NPC",
    Values = {"Ram", "Scientist", "Silly Fisherman", "Lava Fisherman", "Alien Merchant", "Aura Kid", "Scott", "Jim", "Ron"},
    Default = "Ram",
    Callback = function(value)
        selectedNPC = value
    end
})

NPCSection:Button({
    Title = "Teleport To NPC", 
    Callback = function()
        if not selectedNPC then return warn("Select an NPC first!") end

        local NPCTeleports = {
            Ram = Vector3.new(-2841, 47.5, 1963),
            Scientist = Vector3.new(-5, 16.813, 2881),
            ["Silly Fisherman"] = Vector3.new(99, 10, 2690),
            ["Lava Fisherman"] = Vector3.new(-594, 59, 131),
            ["Alien Merchant"] = Vector3.new(-136, 3, 2766),
            ["Aura Kid"] = Vector3.new(71, 17, 2835),
            Scott = Vector3.new(-17, 10, 2709),
            Jim = Vector3.new(86, 10, 2803),
            Ron = Vector3.new(-52, 17, 2854)
        }

        local pos = NPCTeleports[selectedNPC]
        local player = game.Players.LocalPlayer
        local char = player.Character or player.CharacterAdded:Wait()
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if hrp then
            hrp.CFrame = CFrame.new(pos)
        else
            warn("HumanoidRootPart not found.")
        end
    end
})
-- ========================
-- Shops Teleports Section
-- ========================
local ShopsSection = TeleportsTab:Section({
    Icon = "shopping-cart",
    Title = "Shops Teleport", 
})

local selectedShop = nil
ShopsSection:Dropdown({
    Title = "Select Shop",
    Values = {"Fish Merchant", "Baits & Co", "Joe's Rods", "Billy Bob's Shop", "Weasel's Utilities", "Boat Shop"},
    Default = "Fish Merchant",
    Callback = function(value)
        selectedShop = value
    end
})

ShopsSection:Button({
    Title = "Teleport To Shops",
    Callback = function()
        if not selectedShop then return warn("Select a shop first!") end

        local ShopTeleports = {
            ["Fish Merchant"] = Vector3.new(49, 17.284, 2869),
            ["Baits & Co"] = Vector3.new(111, 17.284, 2867),
            ["Joe's Rods"] = Vector3.new(145, 20.459, 2834),
            ["Billy Bob's Shop"] = Vector3.new(80, 17.284, 2867),
            ["Weasel's Utilities"] = Vector3.new(-36, 20.46, 2876),
            ["Boat Shop"] = Vector3.new(33, 9.558, 2789)
        }

        local pos = ShopTeleports[selectedShop]
        local player = game.Players.LocalPlayer
        local char = player.Character or player.CharacterAdded:Wait()
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if hrp then
            hrp.CFrame = CFrame.new(pos)
        else
            warn("HumanoidRootPart not found.")
        end
    end
})

-- ==============================
-- üõí Auto Buy Tab (Fixed IDs)
-- ==============================
local AutoBuyTab = Window:Tab({
    Title = "AutoBuy", 
    Icon = "shopping-cart",
    Locked = false
})

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Remotes
local RodRemote = ReplicatedStorage.Packages._Index["sleitnick_net@0.2.0"].net["RF/PurchaseFishingRod"]
local BaitRemote = ReplicatedStorage.Packages._Index["sleitnick_net@0.2.0"].net["RF/PurchaseBait"]

-- ===== Improved rod detection + dropdown (drop-in replacement) =====
local RodSection = AutoBuyTab:Section({
    Title = "Buy Rods", 
    Icon = "fish"
})

local rods = {}             -- name -> id
local selectedRodId = nil

local function tryGetItemDataId(itemUtil, itemType, name)
    if not itemUtil then return nil end
    local ok, data = pcall(function()
        return itemUtil.GetItemDataFromItemType(itemType, name)
    end)
    if ok and data and data.Data and data.Data.Id then
        return data.Data.Id
    end
    return nil
end

local function tryRequireModuleForId(module)
    local ok, m = pcall(require, module)
    if ok and type(m) == "table" then
        if m.Data and m.Data.Id then
            return m.Data.Id, (m.Data.Name or module.Name)
        elseif m.Id then
            return m.Id, (m.Name or module.Name)
        end
    end
    return nil, nil
end

local function scanRods()
    rods = {}
    local itemUtil = nil
    pcall(function() itemUtil = require(ReplicatedStorage.Shared.ItemUtility) end)

    -- 1) scan common Rod Store locations under Workspace.Islands (robust)
    local success, islandsRoot = pcall(function() return Workspace:FindFirstChild("Islands") end)
    if success and islandsRoot then
        for _, island in ipairs(islandsRoot:GetDescendants()) do
            if island:IsA("Folder") or island:IsA("Model") then
                if island.Name == "Rod Store" or island.Name:lower():find("rod") or (island.Parent and island.Parent.Name and island.Parent.Name:lower():find("rod")) then
                    local folder = island:FindFirstChild("Folder") or island
                    for _, child in ipairs(folder:GetChildren()) do
                        local name = child.Name
                        local id = tryGetItemDataId(itemUtil, "Fishing Rods", name)
                        if not id then
                            if child:IsA("ModuleScript") then
                                local mid, mname = tryRequireModuleForId(child)
                                id = mid or id
                                if mname and (not rods[mname]) and id then
                                    rods[mname] = id
                                end
                            end
                        end
                        if id then rods[name] = id end
                    end
                end
            end
        end
    end

    -- 2) fallback: check the known Fisherman Island Rod Store specifically (if present)
    pcall(function()
        local rf = Workspace.Islands and Workspace.Islands:FindFirstChild("Fisherman Island")
        if rf then
            local store = rf:FindFirstChild("Rod Store")
            if store then
                local folder = store:FindFirstChild("Folder") or store
                for _, child in ipairs(folder:GetChildren()) do
                    local name = child.Name
                    if not rods[name] then
                        local id = tryGetItemDataId(itemUtil, "Fishing Rods", name)
                        if not id and child:IsA("ModuleScript") then
                            local mid, mname = tryRequireModuleForId(child)
                            id = mid or id
                            if mname and (not rods[mname]) and id then
                                rods[mname] = id
                            end
                        end
                        if id then rods[name] = id end
                    end
                end
            end
        end
    end)

    -- 3) scan ReplicatedStorage for ModuleScripts that look like rod definitions
    for _, obj in ipairs(ReplicatedStorage:GetDescendants()) do
        if obj:IsA("ModuleScript") then
            local lname = obj.Name:lower()
            local parentName = obj.Parent and (obj.Parent.Name or ""):lower() or ""
            if lname:find("rod") or parentName:find("rod") or parentName:find("rods") then
                local id, name = tryRequireModuleForId(obj)
                if id and name then
                    rods[name] = id
                end
            end
        end
    end

    -- 4) extra catch-all: scan Workspace descendants with "Rod" in name
    for _, obj in ipairs(Workspace:GetDescendants()) do
        if obj.Name and obj.Name:lower():find("rod") then
            local name = obj.Name
            if not rods[name] then
                local id = tryGetItemDataId(itemUtil, "Fishing Rods", name)
                if not id and obj:IsA("ModuleScript") then
                    local mid, mname = tryRequireModuleForId(obj)
                    id = mid or id
                    if mname and (not rods[mname]) and id then
                        rods[mname] = id
                    end
                end
                if id then rods[name] = id end
            end
        end
    end

        -- build sorted list for dropdown
    local names = {}
    for n,_ in pairs(rods) do table.insert(names, n) end
    table.sort(names)
    return names
end

-- initial build
local rodNames = scanRods()
if #rodNames > 0 then
    selectedRodId = rods[rodNames[1]]
end

-- create dropdown
local rodDropdown = AutoBuyTab:Dropdown({
    Title = "Select Rod",
    Values = rodNames,
    Default = rodNames[1],
    Callback = function(value)
        selectedRodId = rods[value]
    end
})

-- Buy button (keeps your existing buy behavior)
AutoBuyTab:Button({
    Title = "Buy Selected Rod",
    Callback = function()
        if selectedRodId then
            pcall(function()
                RodRemote:InvokeServer(selectedRodId)
            end)
        else
            warn("No rod selected!")
        end
    end
})

-- =====================================================================


-- ==============================
-- Detect Baits with IDs
-- ==============================
local BaitSection = AutoBuyTab:Section({
    Title = "Baits", 
    Icon = "bug"
})

local baits = {}
local BaitFolder = ReplicatedStorage:WaitForChild("Baits")
for _, baitModule in ipairs(BaitFolder:GetChildren()) do
    local success, baitData = pcall(require, baitModule)
    if success and baitData and baitData.Data and baitData.Data.Id and baitData.Data.Name then
        baits[baitData.Data.Name] = baitData.Data.Id
    end
end
local selectedBaitId = next(baits) and baits[next(baits)] or nil

-- Bait Dropdown
AutoBuyTab:Dropdown({
    Title = "Select Bait",
    Values = (function() local t={} for k,_ in pairs(baits) do table.insert(t,k) end return t end)(),
    Default = next(baits),
    Callback = function(value)
        selectedBaitId = baits[value]
    end
})

-- Bait Buy Button
AutoBuyTab:Button({
    Title = "Buy Bait", 
    Callback = function()
        if selectedBaitId then
            pcall(function()
                BaitRemote:InvokeServer(selectedBaitId)
            end)
        else
            warn("No bait selected!")
        end
    end
})

-- ==============================
-- Detect Boats with IDs
-- ==============================
local BoatSection = AutoBuyTab:Section({
    Title = "Boats", 
    Icon = "boat", 
})

local boats = {}
local BoatRemote = ReplicatedStorage.Packages._Index["sleitnick_net@0.2.0"].net["RF/PurchaseBoat"]

-- Example: boats are stored in ReplicatedStorage.Boats folder
local BoatFolder = ReplicatedStorage:WaitForChild("Boats") -- make sure this exists
for _, boatModule in ipairs(BoatFolder:GetChildren()) do
    local success, boatData = pcall(require, boatModule)
    if success and boatData and boatData.Data and boatData.Data.Id and boatData.Data.Name then
        boats[boatData.Data.Name] = boatData.Data.Id
    end
end
local selectedBoatId = next(boats) and boats[next(boats)] or nil

-- Boat Dropdown
AutoBuyTab:Dropdown({
    Title = "Select Boat",
    Values = (function() local t={} for k,_ in pairs(boats) do table.insert(t,k) end return t end)(),
    Default = next(boats),
    Callback = function(value)
        selectedBoatId = boats[value]
    end
})

-- Buy Selected Boat Button
AutoBuyTab:Button({
    Title = "Buy Boat", 
    Callback = function()
        if selectedBoatId then
            pcall(function()
                BoatRemote:InvokeServer(selectedBoatId)
            end)
        else
            warn("No boat selected!")
        end
    end
})

Window:Divider()

-- Bypass Tab
local BypassTab = Window:Tab({ 
    Title = "Bypass", 
    Icon = "shield", 
    Locked = false 
})

BypassTab:Section({
    Icon = "shield",
    Title = "Game Bypass", 
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Lighting = game:GetService("Lighting")
local player = Players.LocalPlayer

-- Require SwimController properly
local SwimControllerModule = require(game:GetService("ReplicatedStorage"):WaitForChild("Controllers"):WaitForChild("SwimController"))

local InfiniteOxygen = false

-- Toggle
BypassTab:Toggle({
    Title = "infinite oxygen", 
    Icon = "shield",
    StartingState = false,
    Callback = function(state)
        InfiniteOxygen = state

        -- Handle turning off
        if not state and player.Character then
            -- Stop blocking oxygen loss
            if SwimControllerModule.BlockOxygenLoss then
                SwimControllerModule:BlockOxygenLoss(false)
            end

            -- Restore blur (optional: you can tweak the default size)
            if Lighting:FindFirstChild("Blur") then
                Lighting.Blur.Size = 12
            end
        end
    end
})

-- Heartbeat loop to enforce infinite oxygen, no blur, no damage
RunService.Heartbeat:Connect(function()
    if InfiniteOxygen and player.Character then
        -- Prevent oxygen loss
        if SwimControllerModule.BlockOxygenLoss then
            SwimControllerModule:BlockOxygenLoss(true)
        end

        -- Refill oxygen if there‚Äôs an internal oxygen value
        if SwimControllerModule.Oxygen then
            SwimControllerModule.Oxygen.Current = SwimControllerModule.Oxygen.Max
        end

        -- Remove underwater blur
        if Lighting:FindFirstChild("Blur") then
            Lighting.Blur.Size = 0
        end
    end
end)

-- Handle respawn
player.CharacterAdded:Connect(function()
    task.wait(1)
    if InfiniteOxygen then
        if SwimControllerModule.BlockOxygenLoss then
            SwimControllerModule:BlockOxygenLoss(true)
        end
        if SwimControllerModule.Oxygen then
            SwimControllerModule.Oxygen.Current = SwimControllerModule.Oxygen.Max
        end
        if Lighting:FindFirstChild("Blur") then
            Lighting.Blur.Size = 0
        end
    end
end)

BypassTab:Toggle({
    Title = "Fishing Radar", 
    Default = false,
    Callback = function(state)
        -- state is true when toggled on, false when off
        game:GetService("ReplicatedStorage").Packages._Index["sleitnick_net@0.2.0"]
            .net["RF/UpdateFishingRadar"]:InvokeServer(state)
    end
})

Window:Divider()

-- =========================
-- Fixed Active Event Tap-to-TP (paste after Window exists)
-- =========================
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local player = Players.LocalPlayer

local EventsFolder = ReplicatedStorage:WaitForChild("Events")

-- create/find Events tab & section
local EventsTab = Window:Tab({ Title = "Events", Icon = "compass", Locked = false })
local EventSection = EventsTab:Section({ Icon = "compass", Title = "Active Event Teleports" })

-- exclude list (case-insensitive substrings)
local excludePatterns = { "wind", "storm", "snow", "day", "night", "cloudy" }
local function isExcluded(name)
    if not name then return false end
    local ln = tostring(name):lower()
    for _, pat in ipairs(excludePatterns) do
        if ln:find(pat, 1, true) then return true end
    end
    return false
end

-- safe require
local function safeRequire(m)
    if not m then return nil end
    local ok, res = pcall(require, m)
    if ok and type(res) == "table" then return res end
    return nil
end

-- see if event listed in ActiveEvents/RunningEvents
local function listedInActiveFolder(name)
    local folder = ReplicatedStorage:FindFirstChild("ActiveEvents") or ReplicatedStorage:FindFirstChild("RunningEvents")
    if folder and folder:FindFirstChild(name) then return true end
    return false
end

-- check workspace direct presence by name
local function workspaceHasName(name)
    if not name then return false end
    if Workspace:FindFirstChild(name) then return true end
    for _, d in ipairs(Workspace:GetDescendants()) do
        if d:IsA("BasePart") or d:IsA("Model") then
            if tostring(d.Name) == name then return true end
        end
    end
    return false
end

-- find the closest part to a Vector3 within a radius
local function findNearbyPart(pos, radius)
    radius = radius or 12
    local closest = nil
    local best = math.huge
    for _, p in ipairs(Workspace:GetDescendants()) do
        if p:IsA("BasePart") then
            local ok, dist = pcall(function() return (p.Position - pos).Magnitude end)
            if ok and dist and dist <= radius and dist < best then
                best = dist
                closest = p
            end
        end
    end
    return closest
end

-- returns (isActive:boolean, bestCFrame or nil)
local function evaluateEvent(modInstance)
    if not modInstance then return false, nil end

    -- if instance is not a ModuleScript, try BoolValue 'Active' or presence in workspace/folders
    if not modInstance:IsA("ModuleScript") then
        -- Active BoolValue
        local act = modInstance:FindFirstChild("Active")
        if act and act:IsA("BoolValue") then
            if not act.Value then return false, nil end
        end
        -- in active folder
        if listedInActiveFolder(modInstance.Name) then
            -- try find location from ObjectValue/CFrameValue inside modInstance
            local cv = modInstance:FindFirstChildOfClass("CFrameValue")
            if cv then return true, cv.Value end
            local vv = modInstance:FindFirstChildOfClass("Vector3Value")
            if vv then return true, CFrame.new(vv.Value) end
            local ov = modInstance:FindFirstChildOfClass("ObjectValue")
            if ov and ov.Value then
                local v = ov.Value
                if v:IsA("BasePart") then return true, v.CFrame end
                if v:IsA("Model") and v.PrimaryPart then return true, v.PrimaryPart.CFrame end
            end
            -- fallback to workspace presence
            if workspaceHasName(modInstance.Name) then
                -- get workspace model/part cframe
                local w = Workspace:FindFirstChild(modInstance.Name)
                if w then
                    if w:IsA("BasePart") then return true, w.CFrame end
                    if w:IsA("Model") then
                        if w.PrimaryPart then return true, w.PrimaryPart.CFrame end
                        local p = w:FindFirstChildOfClass("BasePart")
                        if p then return true, p.CFrame end
                    end
                end
            end
            return true, nil
        end
        -- not listed and no workspace presence -> not active
        if workspaceHasName(modInstance.Name) then
            local w = Workspace:FindFirstChild(modInstance.Name)
            if w then
                if w:IsA("BasePart") then return true, w.CFrame end
                if w:IsA("Model") and w.PrimaryPart then return true, w.PrimaryPart.CFrame end
            end
        end
        return false, nil
    end

    -- module is ModuleScript: try require to get the data table
    local data = safeRequire(modInstance) or {}
    local evName = data.Name or modInstance.Name

    -- quick exclusion
    if isExcluded(evName) then return false, nil end

    -- 1) explicit Active BoolValue under the module instance
    local explicitActive = modInstance:FindFirstChild("Active")
    if explicitActive and explicitActive:IsA("BoolValue") then
        if not explicitActive.Value then return false, nil end
    end

    -- 2) listed in Active folder
    if listedInActiveFolder(evName) then
        -- try to resolve location from ActiveEvents entry if present
        local activeFolder = ReplicatedStorage:FindFirstChild("ActiveEvents") or ReplicatedStorage:FindFirstChild("RunningEvents")
        if activeFolder then
            local entry = activeFolder:FindFirstChild(evName)
            if entry then
                local cv = entry:FindFirstChildOfClass("CFrameValue")
                if cv then return true, cv.Value end
                local vv = entry:FindFirstChildOfClass("Vector3Value")
                if vv then return true, CFrame.new(vv.Value) end
                local ov = entry:FindFirstChildOfClass("ObjectValue")
                if ov and ov.Value then
                    local v = ov.Value
                    if v:IsA("BasePart") then return true, v.CFrame end
                    if v:IsA("Model") and v.PrimaryPart then return true, v.PrimaryPart.CFrame end
                end
            end
        end
        -- else fall through to try coordinates
    end

    -- 3) workspace presence by event name
    if workspaceHasName(evName) then
        local w = Workspace:FindFirstChild(evName)
        if w then
            if w:IsA("BasePart") then return true, w.CFrame end
            if w:IsA("Model") and w.PrimaryPart then return true, w.PrimaryPart.CFrame end
            local p = w and w:FindFirstChildOfClass("BasePart")
            if p then return true, p.CFrame end
        end
    end

    -- 4) coordinates in module data
    if data.Coordinates and type(data.Coordinates) == "table" and #data.Coordinates > 0 then
        for _, coord in ipairs(data.Coordinates) do
            if typeof(coord) == "Vector3" then
                -- find nearby part to this coordinate (meaning event area spawned)
                local part = findNearbyPart(coord, 14)
                if part then
                    return true, part.CFrame
                end
            elseif typeof(coord) == "CFrame" then
                local part = findNearbyPart(coord.Position, 14)
                if part then return true, part.CFrame end
            end
        end
        -- if coordinates exist but no nearby part found, still treat as active if listed in Active folder or workspace presence already detected earlier
        if listedInActiveFolder(evName) then
            local c = data.Coordinates[1]
            if typeof(c) == "Vector3" then return true, CFrame.new(c) end
            if typeof(c) == "CFrame" then return true, c end
        end
    end

    -- fallback: not active
    return false, nil
end

-- build active event map: name -> cframe (may be nil if no resolved location)
local function buildActiveEventMap()
    local map = {}
    local seenNames = {} -- avoid duplicates
    for _, child in ipairs(EventsFolder:GetChildren()) do
        local nameKey = child.Name
        local ok, isActive, cf = pcall(function() 
            local a, b = evaluateEvent(child)
            return a, b
        end)
        if ok and isActive then
            -- prefer module's internal display name if present
            local data = safeRequire(child)
            local displayName = (data and data.Name) or child.Name
            if not isExcluded(displayName) and not seenNames[displayName] then
                map[displayName] = cf -- may be nil
                seenNames[displayName] = true
            end
        end
    end
    return map
end

-- helper to convert cframe to string key (rounded) to avoid duplicates if needed
local function cfKey(cf)
    if not cf then return nil end
    local p = cf.Position
    local rx = math.floor(p.X + 0.5)
    local ry = math.floor(p.Y + 0.5)
    local rz = math.floor(p.Z + 0.5)
    return rx .. "|" .. ry .. "|" .. rz
end

-- build UI dropdown with the active events map
local dropdown = nil
local selectedEventName = nil

local function updateDropdownFromMap(map)
    local names = {}
    for n, _ in pairs(map) do table.insert(names, n) end
    table.sort(names)
    if dropdown and type(dropdown.UpdateValues) == "function" then
        pcall(function() dropdown:UpdateValues(names) end)
        -- try to preserve selection
        if not selectedEventName and names[1] then selectedEventName = names[1] end
    else
        -- create dropdown once (if not created) or recreate (best-effort)
        if not dropdown then
            dropdown = EventSection:Dropdown({
                Title = "Select Active Event",
                Values = names,
                Default = names[1],
                Callback = function(value) selectedEventName = value end
            })
            selectedEventName = names[1]
        else
            -- can't dynamically update; recreate dropdown (some UI libs append instead of replace; this is best-effort)
            dropdown = EventSection:Dropdown({
                Title = "Select Active Event",
                Values = names,
                Default = names[1],
                Callback = function(value) selectedEventName = value end
            })
            selectedEventName = names[1]
            print("Warning: Dropdown.UpdateValues not available; recreated dropdown. If UI stacks multiple dropdowns, reload script and enable UpdateValues method if possible.")
        end
    end
end

-- initial populate
local currentMap = buildActiveEventMap()
updateDropdownFromMap(currentMap)

-- Teleport button: re-check active when pressed and teleport to found cframe (or fallback to module coordinate)
EventSection:Button({
    Title = "Tap to TP",
    Callback = function()
        if not selectedEventName then
            print("No active event selected.")
            return
        end
        -- find module by display name
        local foundModule = nil
        local foundData = nil
        for _, child in ipairs(EventsFolder:GetChildren()) do
            local data = safeRequire(child) or {}
            local display = (data.Name) or child.Name
            if display == selectedEventName then
                foundModule = child
                foundData = data
                break
            end
        end
        if not foundModule then
            print("Event module not found for:", selectedEventName)
            return
        end

        local isActive, cf = pcall(function() return evaluateEvent(foundModule) end)
        -- evaluateEvent inside pcall returns (active, cf) but pcall wrapper returns ok, then active/cf
        -- we need to call evaluateEvent directly to get correct returns:
        local active, bestCf = evaluateEvent(foundModule)
        if not active then
            if WindUI and WindUI.Notify then
                WindUI:Notify({ Title = "this event is not active", Description = selectedEventName .. " is not active.", Duration = 3 })
            else
                print(selectedEventName .. " is not active.")
            end
            return
        end

        -- prefer resolved cf; if nil, try module Coordinates first coordinate
        if not bestCf and foundData and foundData.Coordinates and #foundData.Coordinates > 0 then
            local c = foundData.Coordinates[1]
            if typeof(c) == "Vector3" then bestCf = CFrame.new(c) end
            if typeof(c) == "CFrame" then bestCf = c end
        end

        -- fallback: workspace model/part with that name
        if not bestCf and Workspace:FindFirstChild(foundModule.Name) then
            local w = Workspace:FindFirstChild(foundModule.Name)
            if w:IsA("BasePart") then bestCf = w.CFrame end
            if w:IsA("Model") and w.PrimaryPart then bestCf = w.PrimaryPart.CFrame end
            if w:IsA("Model") then
                local p = w:FindFirstChildOfClass("BasePart")
                if p then bestCf = p.CFrame end
            end
        end

        if bestCf then
            -- teleport
            local char = player.Character or player.CharacterAdded:Wait()
            local hrp = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso")
            if hrp then
                hrp.CFrame = bestCf + Vector3.new(0, 3, 0)
            else
                print("No HRP to teleport.")
            end
        else
            if WindUI and WindUI.Notify then
                WindUI:Notify({ Title = "could not find location", Description = "Could not find location for: " .. selectedEventName, Duration = 4 })
            else
                print("Could not find location for: " .. selectedEventName)
            end
        end
    end
})

-- ===== Refresh Events Dropdown Button (paste inside EventSection scope) =====
EventSection:Button({
    Title = "Refresh Events",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local EventsFolder = ReplicatedStorage:FindFirstChild("Events")
        if not EventsFolder then
            warn("Events folder not found in ReplicatedStorage")
            return
        end

        -- prefer existing high-quality builder if present
        local names = nil
        if type(getActiveEventsList) == "function" then
            local ok, res = pcall(getActiveEventsList)
            if ok and type(res) == "table" and #res > 0 then
                names = res
            else
                -- fallback to simple listing
                names = {}
            end
        end

        -- fallback: simple listing + exclude weather/time keywords (if getActiveEventsList not available or returned nothing)
        if not names or #names == 0 then
            local excludePatterns = { "wind", "storm", "snow", "day", "night", "cloudy" }
            local function isExcluded(n)
                if not n then return false end
                local ln = tostring(n):lower()
                for _, pat in ipairs(excludePatterns) do
                    if ln:find(pat, 1, true) then return true end
                end
                return false
            end

            names = {}
            for _, ev in ipairs(EventsFolder:GetChildren()) do
                local displayName = ev.Name
                -- try to prefer in-module Name if require works
                local ok, data = pcall(function() if ev:IsA("ModuleScript") then return require(ev) end end)
                if ok and type(data) == "table" and data.Name then displayName = data.Name end
                if not isExcluded(displayName) then
                    table.insert(names, displayName)
                end
            end
            table.sort(names)
        end

        -- ensure at least empty table
        names = names or {}

        -- Update existing dropdown if it has UpdateValues
        if dropdown and type(dropdown.UpdateValues) == "function" then
            pcall(function() dropdown:UpdateValues(names) end)
            print("Events dropdown updated (" .. tostring(#names) .. " items).")
            -- preserve selection variable if present
            if names[1] and selectedEventName == nil then selectedEventName = names[1] end
            return
        end

        -- If UpdateValues not supported, recreate the dropdown (safe, best-effort)
        -- remove old reference (UI libs usually handle duplicates; if not, you can reload script)
        print("Dropdown.UpdateValues not available ‚Äî recreating events dropdown.")
        dropdown = EventSection:Dropdown({
            Title = "Select Active Event",
            Values = names,
            Default = names[1],
            Callback = function(value)
                selectedEventName = value
            end
        })
        selectedEventName = names[1]
        print("Recreated events dropdown (" .. tostring(#names) .. " items).")
    end
})

Window:Divider()

-- ===== LocalPlayer + Misc (walk-on-water removed) =====
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")

local LocalPlayer = Players.LocalPlayer

-- state
local speedEnabled = false
local speedValue = 50
local infJumpEnabled = false

local function getCharParts()
    local char = LocalPlayer.Character or (LocalPlayer.CharacterAdded and LocalPlayer.CharacterAdded:Wait())
    if not char then return nil end
    local hrp = char:FindFirstChild("HumanoidRootPart") or char:WaitForChild("HumanoidRootPart", 2)
    local humanoid = char:FindFirstChild("Humanoid") or char:WaitForChild("Humanoid", 2)
    return char, hrp, humanoid
end

-- ===== LocalPlayer tab =====
local LocalPlayerTab = Window:Tab({
    Title = "Local Player", 
    Icon = "user",
    Locked = false,
})

if LocalPlayerTab then
    -- Speed toggle
    LocalPlayerTab:Toggle({
        Title = "Speed Hack",
        Default = false,
        Callback = function(state)
            speedEnabled = state
            local _, _, humanoid = getCharParts()
            if humanoid then
                pcall(function() humanoid.WalkSpeed = state and speedValue or 16 end)
            end
        end
    })

    -- Speed slider
    LocalPlayerTab:Slider({
        Title = "Speed Value",
        Step = 1,
        Value = { Min = 16, Max = 250, Default = 50 },
        Callback = function(value)
            speedValue = value or 50
            if speedEnabled then
                local _, _, humanoid = getCharParts()
                if humanoid then pcall(function() humanoid.WalkSpeed = speedValue end) end
            end
        end
    })

    -- Infinite Jump toggle
    LocalPlayerTab:Toggle({
        Title = "Infinite Jump",
        Default = false,
        Callback = function(state) infJumpEnabled = state end
    })
end

-- Jump handling
UserInputService.JumpRequest:Connect(function()
    if not infJumpEnabled then return end
    local _, _, humanoid = getCharParts()
    if humanoid then pcall(function() humanoid:ChangeState(Enum.HumanoidStateType.Jumping) end) end
end)

-- ===== MISC TAB =====
local MiscTab = Window:Tab({
    Title = "Misc", 
    Icon = "cog",
    Locked = false,
})

if MiscTab then
    -- Rejoin
    MiscTab:Button({
        Title = "Rejoin",
        Callback = function() pcall(function() TeleportService:Teleport(game.PlaceId, LocalPlayer) end) end
    })

    -- Server Hop
    MiscTab:Button({
        Title = "Server Hop",
        Callback = function()
            local PlaceID = game.PlaceId
            local ok, body = pcall(function()
                return game:HttpGet("https://games.roblox.com/v1/games/"..PlaceID.."/servers/Public?sortOrder=Asc&limit=100")
            end)
            if not ok or not body then
                warn("Failed to fetch servers.")
                return
            end

            local parsedOk, parsed = pcall(function() return HttpService:JSONDecode(body) end)
            if not parsedOk or not parsed or type(parsed.data) ~= "table" then
                warn("Failed to parse server list.")
                return
            end

            local servers = {}
            for _, v in pairs(parsed.data) do
                if v.id and v.id ~= game.JobId and v.playing < v.maxPlayers then
                    table.insert(servers, v.id)
                end
            end

            if #servers == 0 then
                warn("No servers available to hop.")
                return
            end

            local selected = servers[math.random(1, #servers)]
            pcall(function() TeleportService:TeleportToPlaceInstance(PlaceID, selected, LocalPlayer) end)
        end
    })
end

-- üé® Theme Dropdown
local ThemeDropdown = MiscTab:Dropdown({
    Title = "Select Theme",
    Values = themeNames,
    Value = "Volcano",
    Callback = function(selectedTheme)
        WindUI:SetTheme(selectedTheme)
    end
})

-- ü™ü Transparent Window Toggle
MiscTab:Toggle({
    Title = "Transparent Window",
    Desc = "Toggle UI transparency on or off",
    Default = false, -- starts off
    Callback = function(state)
        if state then
            Window:ToggleTransparency(true)
        else
            Window:ToggleTransparency(false)
        end
    end
})

-- ‚úÖ Show popup after UI is ready
task.delay(0.2, function()
	WindUI:Popup({
		Title = "Successfully Loaded",
		Icon = "info",
		Content = "Made by @mallo! Join our Discord!",
		Buttons = {
			{
				Title = "OK",
				Callback = function() end,
				Variant = "Primary",
			},
		},
	})
end)

print("‚úÖ Wind UI loaded successfully")
